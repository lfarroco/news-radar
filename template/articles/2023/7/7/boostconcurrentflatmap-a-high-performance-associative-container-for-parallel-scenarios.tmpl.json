{"layout":"article.njk","title":"Boost::concurrent_flat_map: A High-Performance Associative Container for Parallel Scenarios","date":"2023-07-07T03:00:00.000Z","formattedDate":"2023-7-7","source_link":"https://bannalia.blogspot.com/2023/07/inside-boostconcurrentflatmap.html","tags":["c"],"topics":[{"name":"C++","slug":"c"}],"content":"<p>Boost::concurrent_flat_map, introduced in Boost 1.83, is a powerful associative container designed specifically for high-load parallel scenarios. This container leverages the work done for boost::unordered_flat_map but introduces innovative features in low-contention operation and API design.</p>\n<p>In the world of C++ concurrent hashmaps, there are various competing techniques, ranging from traditional lock-based structures to specialized approaches like hazard pointers and Read-Copy-Update (RCU). Boost::concurrent_flat_map stands out as a general-purpose container, offering a reference interface that is flexible and efficient.</p>\n<p>One notable design decision is the absence of iterators. Instead, boost::concurrent_flat_map provides an access API based on internal visitation. This approach eliminates the potential risks of unsafe or blocking iterators, reducing contention and the possibility of deadlocks.</p>\n<p>Under the hood, boost::concurrent_flat_map adopts the open-addressing layout used by boost::unordered_flat_map. The bucket array is split into 2n groups, each with 15 slots and an associated 16-byte metadata word for SIMD-based reduced-hash matching and insertion overflow control. This layout ensures efficient and scalable performance.</p>\n<p>To maintain thread safety, boost::concurrent_flat_map incorporates two levels of synchronization. The core algorithms are variations of those found in boost::unordered_flat_map, with minimal modifications to prevent data races and minimize group-level contention.</p>\n<p>The lookup algorithm of boost::concurrent_flat_map is predominantly lock-free, with only a few steps executed within the scope of a group lock. SIMD matching plays a crucial role in identifying potential candidates, while double-checking for slot occupancy and element comparison are performed within the group lock.</p>\n<p>Boost::concurrent_flat_map is a valuable addition to the Boost library, providing developers with a high-performance concurrent hashmap that meets the demands of parallel scenarios. Its efficient design and flexible API make it a go-to choice for developers working on parallel applications.</p>\n<pre><code class=\"language-cpp\">#include &lt;boost/concurrent_flat_map.hpp&gt;\n\nint main() {\n  boost::concurrent_flat_map&lt;int, std::string&gt; map;\n\n  // Insert key-value pairs\n  map.emplace(1, &quot;One&quot;);\n  map.emplace(2, &quot;Two&quot;);\n  map.emplace(3, &quot;Three&quot;);\n\n  // Access values\n  std::cout &lt;&lt; map[1] &lt;&lt; std::endl;  // Output: &quot;One&quot;\n  std::cout &lt;&lt; map[2] &lt;&lt; std::endl;  // Output: &quot;Two&quot;\n  std::cout &lt;&lt; map[3] &lt;&lt; std::endl;  // Output: &quot;Three&quot;\n\n  return 0;\n}\n</code></pre>\n<p>Boost::concurrent_flat_map empowers developers to handle parallel scenarios efficiently while maintaining thread safety. With its robust design and intuitive API, this container is a valuable tool for modern C++ developers. Stay tuned for more updates and news on Boost and other programming languages and frameworks in Dev Radar magazine.</p>\n"}