{"layout":"article.njk","title":"Fastest Branchless Binary Search","date":"2023-07-02T03:00:00.000Z","formattedDate":"2023-7-2","source_link":"https://mhdm.dev/posts/sb_lower_bound/","tags":["c","binary-search"],"topics":[{"name":"C++","slug":"c"},{"name":"Binary Search","slug":"binary-search"}],"content":"<p>In this article, the author presents the fastest implementation of a general binary search in C++. The implementation provides the same function interface as std::lower_bound but is twice as fast and shorter. The key to its speed is that it is &quot;branchless,&quot; meaning that the if statement compiles down to a conditional move instruction instead of a branch or conditional jump. The article also mentions that there are compiler options, even faster versions, fully branchless implementations, and some caveats that will be explored later on.</p>\n<p>The article starts with a brief introduction to binary search, explaining that it is used to find the position where a value would fit in a sorted list. In C++, developers typically use std::lower_bound for this purpose. The author then challenges the readers to write their own binary search implementation as a coding interview question.</p>\n<p>For developers who are not familiar with C++, the author assures that understanding the article only requires knowledge of iterators (pointers to elements in an array) and the concept that they can point one past the last array entry. The article concludes with a mention of the desire for a clean and fast bare-metal language to write this code in.</p>\n<p>To provide more value to our readers, here&#39;s an example of a binary search implementation in C++:</p>\n<pre><code class=\"language-cpp\">template &lt;typename T&gt;\nint binarySearch(const T* arr, int size, const T&amp; value) {\n    int left = 0;\n    int right = size - 1;\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == value) {\n            return mid;\n        }\n\n        if (arr[mid] &lt; value) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1; // Value not found\n}\n</code></pre>\n<p>This implementation takes an array <code>arr</code>, its size <code>size</code>, and the value to search for <code>value</code>. It uses a while loop to iteratively narrow down the search range by comparing the middle element of the current range with the target value. If the middle element is equal to the target value, the function returns the index of that element. If the middle element is less than the target value, the search range is updated to the right half. Otherwise, it is updated to the left half. If the value is not found, the function returns -1.</p>\n<p>By keeping up with the latest developments in binary search implementations, developers can optimize their code for faster search operations.</p>\n"}