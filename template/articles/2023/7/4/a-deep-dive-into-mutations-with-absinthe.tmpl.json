{"layout":"article.njk","title":"A Deep Dive into Mutations with Absinthe","date":"2023-07-04T03:00:00.000Z","formattedDate":"2023-7-4","source_link":"https://blog.appsignal.com/2023/07/04/a-deep-dive-into-mutations-with-absinthe.html","tags":["elixir","absinthe"],"topics":[{"name":"Elixir","slug":"elixir"},{"name":"Absinthe","slug":"absinthe"}],"content":"<p>Absinthe for Elixir is a powerful tool for building GraphQL APIs, and in this article, Sapan Diwakar takes a deep dive into mutations with Absinthe. Mutations in GraphQL are used to modify data on the server, and Absinthe makes it easy to implement them in Elixir.</p>\n<p>The article starts by explaining the difference between queries and mutations in GraphQL. While queries are used to fetch data, mutations are used to modify data. The author provides an example of a mutation to create a new post and explains the structure of a typical mutation in GraphQL.</p>\n<p>Next, the article shows how to implement mutations with Absinthe. It starts by creating an input object that can be used as a variable for the mutation. The author demonstrates how to define an input object using the <code>input_object</code> macro and explains the differences in field definitions between input objects and output types.</p>\n<p>After defining the input object, the article moves on to defining the mutation type in the schema. The author uses the <code>mutation..do..end</code> block to define the base mutation type and creates a field named <code>create_post</code> that takes an argument of the <code>post_create_input</code> type defined earlier.</p>\n<p>To actually perform the mutation operation, the article explains how to define a resolver. The author provides an example of a resolver that creates a post using the <code>post</code> attribute.</p>\n<p>Overall, this article provides a comprehensive guide to implementing mutations with Absinthe for Elixir. It covers the basics of mutations in GraphQL, demonstrates how to define input objects and mutation types in Absinthe, and shows how to write resolvers to handle mutations. For developers looking to build GraphQL APIs with Elixir, this article is a valuable resource.</p>\n<pre><code class=\"language-elixir\"># Example code snippet from the article\n\n# Define an input object\ninput_object :post_create_input do\n  field :title, non_null(:string)\n  field :content, non_null(:string)\n  field :state, :post_state_enum, default_value: :draft\nend\n\n# Define the mutation type\nmutation do\n  field :create_post, :post_mutation_result do\n    arg :post, :post_create_input\n    resolve &amp;Resolvers.create_post/3\n  end\nend\n\n# Resolver to create a post\ndef create_post(_, %{post: post}, _) do\n  # Logic to create a post\nend\n</code></pre>\n<p>For more information on implementing mutations with Absinthe, be sure to check out the full article.</p>\n"}