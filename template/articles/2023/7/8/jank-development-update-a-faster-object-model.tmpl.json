{"layout":"article.njk","title":"Jank Development Update: A Faster Object Model","date":"2023-07-08T03:00:00.000Z","formattedDate":"2023-7-8","source_link":"https://jank-lang.org/blog/2023-07-08-object-model","tags":["clojure"],"topics":[{"name":"Clojure","slug":"clojure"}],"content":"<p>In this quarter&#39;s update, the author shares exciting results from their research on a new object model for Jank, a programming language. The goal of this work is to make Jank code faster overall. While Jank has proven to be faster than Clojure in previous benchmarks, there are still parts of its runtime that are slow. The problem lies in the JVM&#39;s fast allocations, which Clojure heavily relies on. To overcome this, Jank minimizes allocations. However, each allocation still gives Clojure an advantage in benchmarks.</p>\n<p>To understand why Jank&#39;s allocations are slow, it&#39;s important to delve into C++ inheritance and virtual function tables (vtables). In Jank, objects are modeled similarly to Clojure&#39;s Java runtime. Each object, such as a boxed string or hash map, inherits from a base object and overrides certain functionality. These objects have their own vtables and vptrs, which need to be initialized during allocation. This process is handled by the C++ compiler and is implementation-defined.</p>\n<p>To further illustrate this, the author introduces the concept of jank_countable and its impact on vtables. When jank_countable is added to jank_string, the size of the allocated string increases due to the additional pointer to the jank_countable vtable. However, it&#39;s important to note that not every string allocation becomes larger, which could potentially slow down allocations.</p>\n<p>This research on the object model for Jank is part of the author&#39;s work sponsored by Clojurists Together. By addressing the systemic problem of slow allocations, Jank aims to improve its overall performance and compete more effectively with Clojure.</p>\n<p>For developers interested in Jank and its object model, understanding the underlying concepts of C++ inheritance and virtual function tables can provide insights into how Jank achieves its performance optimizations.</p>\n"}