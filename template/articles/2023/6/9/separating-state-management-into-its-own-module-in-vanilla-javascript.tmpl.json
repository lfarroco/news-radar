{"layout":"article.njk","title":"Separating State Management into its Own Module in Vanilla JavaScript","date":"2023-06-09T03:00:00.000Z","formattedDate":"2023-6-9","source_link":"https://dev.to/chovy/state-management-into-its-own-module-in-vanilla-javascript-58mf","tags":["state-management","javascript"],"topics":[{"name":"State Management","slug":"state-management"},{"name":"JavaScript","slug":"javascript"}],"content":"<p>State management is an essential part of any application, and it can become complex as the application grows. It is crucial to organize the code in a way that makes it easy to manage and maintain. Separating the state management into its own module is an effective way to do this.</p>\n<p>In this article, we will show you how to separate state management into its own module in vanilla JavaScript. We will provide you with an example that you can use in your own projects.</p>\n<p>To begin with, we will create a file called store.js, which will contain the state management code. The first step is to define the initial state. In our example, we will create a state object that contains a count property, which is initialized to 0.</p>\n<pre><code>// Define the initial state\nlet state = { count: 0 };\n</code></pre>\n<p>Next, we will define a list of subscribers. These are functions that will be called whenever the state changes. In our example, we will create an empty array called subscribers.</p>\n<pre><code>// Define a list of subscribers\nlet subscribers = [];\n</code></pre>\n<p>We will then define a function called setState, which will update the state and notify the subscribers. The function takes a new state object as an argument and updates the state variable. It then loops over the subscribers array and calls each function with the new state object.</p>\n<pre><code>// Define a function to update the state and notify subscribers\nfunction setState(newState) {\n  state = newState;\n  // Notify subscribers\n  for (let i = 0; i &lt; subscribers.length; i++) {\n    subscribers[i](newState);\n  }\n}\n</code></pre>\n<p>We will also define a function called subscribe, which allows other parts of the application to subscribe to state changes. The function takes a callback function as an argument and adds it to the subscribers array.</p>\n<pre><code>// Define a function to subscribe to state changes\nfunction subscribe(callback) {\n  subscribers.push(callback);\n}\n</code></pre>\n<p>Finally, we will export the state, setState, and subscribe functions so that they can be used in other parts of the application.</p>\n<pre><code>// Export the state, setState, and subscribe functions\nexport { state, setState, subscribe };\n</code></pre>\n<p>Now that we have defined the state management code in store.js, we can use it in other parts of the application. In our example, we will create a file called main.js, which will contain the code that uses the state management module.</p>\n<p>First, we will import the state, setState, and subscribe functions from store.js.</p>\n<pre><code>import { state, setState, subscribe } from &#39;./store.js&#39;;\n</code></pre>\n<p>We will then subscribe a function that updates the DOM to state changes. In our example, we will update the count element with the new count value.</p>\n<pre><code>// Subscribe a function that updates the DOM to state changes\nsubscribe(function(newState) {\n  document.getElementById(&#39;count&#39;).textContent = &quot;Count: &quot; + newState.count;\n});\n</code></pre>\n<p>Next, we will define a function called incrementCount, which will increment the count property of the state object by 1.</p>\n<pre><code>// Define a function to increment the count\nfunction incrementCount() {\n  setState({ count: state.count + 1 });\n}\n</code></pre>\n<p>Finally, we will call the incrementCount function to increment the count value.</p>\n<pre><code>// Call the function to increment the count\nincrementCount();\n</code></pre>\n<p>By separating the state management into its own module, we have made it easier to manage and maintain the code. We can now add more functionality to the state management module without affecting the rest of the application.</p>\n<p>In conclusion, separating state management into its own module is an effective way to organize code in vanilla JavaScript. It makes it easier to manage and maintain the code as the application grows. The example we provided can be used as a starting point for your own projects.</p>\n"}