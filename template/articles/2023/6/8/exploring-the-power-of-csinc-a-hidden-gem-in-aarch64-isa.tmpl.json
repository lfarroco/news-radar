{"layout":"article.njk","title":"\"Exploring the Power of csinc: A Hidden Gem in AArch64 ISA\"","date":"2023-06-08T03:00:00.000Z","formattedDate":"2023-6-8","source_link":"https://danlark.org/2023/06/06/csinc-the-arm-instruction-you-didnt-know-you-wanted/","tags":["aarch64"],"topics":[{"name":"AArch64","slug":"aarch64"}],"content":"<p>When it comes to conditional moves, most developers are familiar with the x86 instruction cmov. However, there&#39;s an underrated feature of AArch64 ISA that is often overlooked but used by compilers a lot - csinc. In this article, we&#39;ll explore the power of csinc and why it&#39;s a hidden gem for developers.</p>\n<p>First, let&#39;s take a step back and understand what conditional moves are. Conditional moves are instructions that allow you to conditionally set the value of a register based on a condition. This can be useful in low-level optimization, such as when merging two arrays. Traditionally, conditional moves are associated with the x86 instruction cmov.</p>\n<p>However, AArch64 ISA has its own version of conditional moves - csinc. What makes csinc unique is its ability to perform a conditional increment or decrement in a single instruction. This can be incredibly useful in situations where you need to increment or decrement a value based on a condition.</p>\n<p>Let&#39;s take a look at an example. Say we have a variable x and we want to increment it if y is greater than z. In C, we would write:</p>\n<p>if (y &gt; z) {\n    x++;\n}</p>\n<p>In AArch64 assembly, we can use csinc to achieve the same result:</p>\n<p>csinc w0, w0, wzr, gt</p>\n<p>In this instruction, w0 is the destination register, w0 is the source register, wzr is the zero register, and gt is the condition code. If the condition gt is true (y &gt; z), then w0 is incremented. Otherwise, w0 remains unchanged.</p>\n<p>Csinc can also be used to perform a conditional decrement. For example, if we want to decrement x if y is less than z, we can use the following instruction:</p>\n<p>csinc w0, w0, wzr, lt</p>\n<p>Csinc is not only useful for incrementing and decrementing values, but it can also be used to perform other operations based on a condition. For example, we can use csinc to perform a conditional move. Say we have two variables x and y, and we want to move the value of x into y if y is less than z. In AArch64 assembly, we can use the following instruction:</p>\n<p>csinc x0, x1, x0, lt</p>\n<p>In this instruction, x0 is the destination register, x1 is the source register, x0 is the value to be moved if the condition lt is true (y &lt; z).</p>\n<p>Csinc may seem like a small feature, but it can have a big impact on performance. By allowing developers to perform conditional increments and decrements in a single instruction, csinc can help reduce the number of instructions needed to perform certain operations. This can lead to faster and more efficient code.</p>\n<p>In conclusion, csinc is a hidden gem in AArch64 ISA that developers should be aware of. While it may not be as well-known as cmov, csinc&#39;s ability to perform conditional increments and decrements in a single instruction can be incredibly useful in low-level optimization. By taking advantage of csinc, developers can write faster and more efficient code.</p>\n"}