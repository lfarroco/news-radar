{"layout":"article.njk","title":"CommonJS is hurting JavaScript","date":"2023-06-30T03:00:00.000Z","formattedDate":"2023-6-30","source_link":"https://deno.com/blog/commonjs-is-hurting-javascript","tags":["deno","javascript"],"topics":[{"name":"Deno","slug":"deno"},{"name":"JavaScript","slug":"javascript"}],"content":"<p>JavaScript, the undisputed king of web development, is being sabotaged — not by a rival language or a revolutionary new technology, but by its own baggage from the past. This insidious saboteur is none other than CommonJS, the antique module system that we’ve tolerated for far too long.</p>\n<p>The rise of CommonJS\nAbout 15 years after its invention, JavaScript started expanding beyond the browser to the server. Bigger projects were being built with the language and JavaScript needed a better way to handle a lot of source code. It needed modularization.</p>\n<p>In 2009, Mozilla developer Kevin Dangoor made a call to arms in his article &quot;What Server Side JavaScript needs&quot;. He laid out the missing pieces in the nascent field of server-side JS, including a module system. JavaScript needed a standard way to include other modules and for those modules to live in discreet namespaces.</p>\n<p>The birth of Node.js\nKevin Dangoor&#39;s call to arms resonated with many developers, and within a week, 224 people had joined the then-called ServerJS Google group, including npm founder Issac Schlueter and Node.js creator Ryan Dahl. This marked the beginning of a movement that would revolutionize server-side JavaScript development.</p>\n<p>Node.js, built on top of the V8 JavaScript engine, provided a runtime environment that allowed developers to write server-side applications using JavaScript. It introduced a new module system, inspired by CommonJS, but with some crucial differences. This module system, known as the CommonJS module system, became the de facto standard for server-side JavaScript development.</p>\n<p>The limitations of CommonJS\nWhile CommonJS brought modularity to JavaScript, it also introduced some limitations. One of the major drawbacks is its synchronous nature. When a module is required, it is loaded synchronously, which can lead to performance issues in applications with a large number of dependencies.</p>\n<p>Another limitation is the lack of support for static analysis. Since CommonJS modules are loaded dynamically at runtime, it is difficult for tools to analyze the dependencies and optimize the code.</p>\n<p>The rise of ES modules\nRecognizing the limitations of CommonJS, the ECMAScript committee introduced a new module system in ECMAScript 6 (ES6) called ES modules. ES modules are designed to be statically analyzable, allowing tools to perform optimizations and tree shaking. They also support asynchronous loading, which can greatly improve the performance of applications.</p>\n<p>The adoption of ES modules has been growing steadily, with major frameworks and libraries embracing the new module system. However, the transition from CommonJS to ES modules is not without challenges. Many existing codebases still rely on CommonJS, and migrating to ES modules can be a complex and time-consuming process.</p>\n<p>Conclusion\nWhile CommonJS played a crucial role in bringing modularity to JavaScript, its limitations have become apparent as the language evolved. The rise of ES modules offers a more modern and efficient solution for managing dependencies in JavaScript applications. As developers, it is important to stay up-to-date with the latest trends and technologies in the industry, and embrace the changes that will drive the future of JavaScript development.</p>\n"}