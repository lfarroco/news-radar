{"layout":"article.njk","title":"Angular Signals: Extending the Power of Angular","date":"2023-06-19T03:00:00.000Z","formattedDate":"2023-6-19","source_link":"https://medium.com/@viniciusschuelter/angular-primitives-extending-the-power-of-angular-signals-eff8ff57eb63","tags":["angular"],"topics":[{"name":"Angular","slug":"angular"}],"content":"<p>Angular Signals is a new feature that was introduced in Angular v16, released in May. It generated a lot of controversy in the community, as it extends the declarative way of coding around RxJs. In this article, we will explore what Angular Signals are and how they can be used.</p>\n<p>Angular Signals is essentially a wrapper around a simple value that registers what depends on that value and notifies those dependents whenever its value changes. This feature is similar to the observer pattern, where an object maintains a list of its dependents and notifies them automatically of any state changes.</p>\n<p>Despite its simple idea, Angular Signals has been scaring part of the community who feel this new feature could affect the declarative way (FRP) we code around RxJs. However, in the author&#39;s opinion, RxJs will still continue to be a protagonist in Angular development and that Angular Signals came only to help compose this ecosystem.</p>\n<p>So, what are the possible uses for Angular Signals? The best way to validate the power of Angular Signals is to use it as much as possible. A good starting point is to base ourselves on the example provided in the RFC. Let&#39;s take a look at the code snippet below:</p>\n<pre><code class=\"language-typescript\">import { Signal } from &#39;@angular/signals&#39;;\n\n@Component({\n  selector: &#39;app-root&#39;,\n  template: `\n    &lt;input [(ngModel)]=&quot;name&quot;&gt;\n    &lt;p&gt;Hello, {{name}}!&lt;/p&gt;\n  `\n})\nexport class AppComponent {\n  name = &#39;&#39;;\n  nameChanged = new Signal&lt;string&gt;();\n\n  constructor() {\n    this.nameChanged.subscribe((name: string) =&gt; {\n      console.log(`Name changed to ${name}`);\n    });\n  }\n\n  set name(value: string) {\n    this._name = value;\n    this.nameChanged.emit(value);\n  }\n\n  get name(): string {\n    return this._name;\n  }\n}\n</code></pre>\n<p>In this example, we have an input field that is bound to the <code>name</code> property of the component. Whenever the value of the input changes, the <code>name</code> property is updated and the <code>nameChanged</code> signal is emitted with the new value. The signal is subscribed to in the constructor of the component, and whenever the signal is emitted, the console logs the new value.</p>\n<p>This is just a simple example, but it shows the potential of Angular Signals to simplify the code and make it more declarative. By using signals, we can avoid the need for complex event handling and callbacks, and instead rely on a simple and intuitive API.</p>\n<p>In conclusion, Angular Signals is a powerful new feature that extends the power of Angular and simplifies the way we code around RxJs. While it may be controversial, it has the potential to make our code more declarative and easier to read. As developers, it is important to keep up with the latest news and features in the industry, and Angular Signals is definitely a feature worth exploring.</p>\n"}