{"layout":"article.njk","title":"\"Building an MVP with GraphQL for Startups: A Day 21 Update\"","date":"2023-06-06T03:00:00.000Z","formattedDate":"2023-6-6","source_link":"https://knowlo.co/blog/day-21-building-an-mvp-signup-flow-and-graphql/","tags":["ai","graphql"],"topics":[{"name":"AI","slug":"ai"},{"name":"GraphQL","slug":"graphql"}],"content":"<p>Today&#39;s update on building a startup with AI cofounder focuses on the signup flow and the use of GraphQL. This article was originally published on another website.</p>\n<p>On Day 19, our team encountered an issue with AppSync JavaScript resolvers. Although everything seemed to be working perfectly, we realized that JavaScript resolvers do not work for unit resolvers when we tried to deploy the app. Currently, they only support pipeline resolvers.</p>\n<p>To resolve this issue, we explored other options besides JavaScript resolvers, such as VTL resolvers and Lambda functions. However, VTL resolvers are difficult to write and test, and using Lambda functions for reading or writing simple values in the DynamoDB table is overkill. Lambda functions also require more code, have a scaling limit, and are slightly slower than VTL and JavaScript resolvers due to their initialization or cold start.</p>\n<p>Fortunately, we discovered another option that may seem a bit crazy but works perfectly fine for our scenario. We wrapped unit resolvers in a pipeline resolver. But before we delve into that, let&#39;s first explain the difference between unit and pipeline resolvers.</p>\n<p>Each GraphQL query and mutation requires a resolver, which is a function that serves as a bridge between the GraphQL API and the rest of the application. Unit resolvers are simple, standalone resolvers that can be used for basic operations. Pipeline resolvers, on the other hand, are more complex and can be used for multiple operations, such as combining data from multiple sources or performing validation.</p>\n<p>By wrapping unit resolvers in a pipeline resolver, we can take advantage of the benefits of both types of resolvers. We can use simple, standalone resolvers for basic operations and more complex resolvers for more advanced operations. This approach also allows us to avoid the limitations of JavaScript resolvers and the complexity of VTL resolvers and Lambda functions.</p>\n<p>In addition to resolving the resolvers issue, we also worked on the signup flow for our MVP. We used GraphQL mutations to handle user registration and authentication. Here&#39;s an example of a mutation for registering a new user:</p>\n<pre><code>mutation {\n  registerUser(input: {\n    username: &quot;johndoe&quot;,\n    password: &quot;password123&quot;,\n    email: &quot;johndoe@email.com&quot;\n  }) {\n    id\n    username\n    email\n  }\n}\n</code></pre>\n<p>This mutation takes in a user&#39;s username, password, and email and returns the user&#39;s ID, username, and email. We also used GraphQL queries to fetch user data and display it on the frontend.</p>\n<p>Overall, using GraphQL for our MVP has been a great choice. It has allowed us to easily handle complex data operations and has provided a flexible and scalable architecture for our application. We look forward to continuing our journey with GraphQL and building a successful startup with our AI cofounder.</p>\n<p>In conclusion, by wrapping unit resolvers in a pipeline resolver, we were able to overcome the limitations of JavaScript resolvers and avoid the complexity of VTL resolvers and Lambda functions. We also used GraphQL mutations and queries to handle user registration and authentication for our MVP. As developers, it&#39;s important to stay up-to-date with the latest technologies and tools, and GraphQL is definitely a technology worth exploring.</p>\n"}